name: CI

on:
  pull_request:
    types: [closed]
    branches:
      - main

permissions: read-all

jobs:
  test:
    if: ${{ github.event.pull_request.merged == true }}
    name: 3 - Test & Build
    timeout-minutes: 20
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write
    outputs:
      started_at: ${{ steps.start.outputs.started_at }}
      finished_at: ${{ steps.finished.outputs.finished_at }}
      comment_id: ${{ steps.status_comment.outputs.result }}
    steps:
      - id: start
        run: |
          echo "started_at=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> "$GITHUB_OUTPUT"
      - uses: actions/github-script@v7
        id: status_comment
        with:
          result-encoding: string
          script: |
            const MARKER = '<!-- ci-status-marker -->';
            const body = `
            ${MARKER}
            ### ğŸš§ Post-merge pipeline is runningâ€¦
            * **Test & Build**: ğŸ”¸ pending
            * **Report Links Comment**: ğŸ”¸ pending
            * **Release**: ğŸ”¸ pending

            _Workflow:_ \`${context.workflow}\`
            _Run:_ [${context.runNumber}](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}) _If you re-run the workflow, this comment will update automatically._ âœ¨
            `;

            const created = await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body
            });
            return String(created.data.id);

      - uses: actions/checkout@v4
      - uses: pnpm/action-setup@v4
        with:
          version: 10
      - uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: "pnpm"
      - run: pnpm install --frozen-lockfile
      - run: pnpm lint
      - run: pnpm tsc --noEmit
      - run: pnpm coverage
      - run: pnpm build
      - uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./__local__/coverage
          destination_dir: reports/stable/coverage
      - uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./__local__/bundle
          destination_dir: reports/stable/bundle
      - name: Update status for Test & Build
        if: always()
        env:
          STATUS_COMMENT_ID: ${{ steps.status_comment.outputs.result }}
        uses: actions/github-script@v7
        with:
          script: |
            const comment_id = parseInt(process.env.STATUS_COMMENT_ID, 10);
            if (!comment_id) { core.setFailed('STATUS_COMMENT_ID is missing'); return; }
            const finished = new Date().toISOString().replace('T',' ').replace('Z',' UTC');
            const icon = '${{ job.status }}' === 'success' ? 'âœ…' :
                        ('${{ job.status }}' === 'failure' ? 'âŒ' : 'âš ï¸');

            const { data: comment } = await github.rest.issues.getComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id
            });

            const updated = comment.body.replace(
              '**Test & Build**: ğŸ”¸ pending',
              `**Test & Build**: ${icon} finished at ${finished}`
            );

            try {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id,
                body: updated
              });
            } catch (e) {
              if (e.status === 403) {
                core.warning('403 updating status comment; creating a new comment as fallback');
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: updated
                });
              } else {
                throw e;
              }
            }

      - id: finished
        run: |
          echo "finished_at=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> "$GITHUB_OUTPUT"

  comment:
    name: 4 - Report Links Comment
    timeout-minutes: 1
    runs-on: ubuntu-latest
    needs: test
    permissions:
      issues: write
      pull-requests: write
    outputs:
      finished_at: ${{ steps.finished.outputs.finished_at }}
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            const baseUrl = `https://${context.repo.owner}.github.io/${context.repo.repo}/reports/stable`
            const coverageUrl = `${baseUrl}/coverage/index.html`
            const bundleUrl = `${baseUrl}/bundle/sonda_0.html`

            const body = `
            ğŸ“ **Reports for commit \`latest-stable\`**

            - [Coverage Report](${coverageUrl})
            - [Bundle Analysis](${bundleUrl})
            `

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            })

            const existing = comments.find(c => c.user.type === "Bot" && c.body.includes("Reports for commit"))
            if (existing) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body
              })
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body
              })
            }
      - name: Update status for Report Links Comment
        if: always()
        env:
          STATUS_COMMENT_ID: ${{ needs.test.outputs.comment_id }}
        uses: actions/github-script@v7
        with:
          script: |
            const comment_id = parseInt(process.env.STATUS_COMMENT_ID, 10);
            if (!comment_id) { core.setFailed('STATUS_COMMENT_ID is missing'); return; }
            const finished = new Date().toISOString().replace('T',' ').replace('Z',' UTC');
            const icon = '${{ job.status }}' === 'success' ? 'âœ…' :
                        ('${{ job.status }}' === 'failure' ? 'âŒ' : 'âš ï¸');

            const { data: comment } = await github.rest.issues.getComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id
            });
            const updated = comment.body.replace(
              '**Report Links Comment**: ğŸ”¸ pending',
              `**Report Links Comment**: ${icon} finished at ${finished}`
            );

            try {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id,
                body: updated
              });
            } catch (e) {
              if (e.status === 403) {
                core.warning('403 updating status comment; creating a new comment as fallback');
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: updated
                });
              } else {
                throw e;
              }
            }
      - id: finished
        run: |
          echo "finished_at=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> "$GITHUB_OUTPUT"

  release:
    name: 5 - Release
    runs-on: ubuntu-latest
    needs: test
    permissions:
      contents: write
      issues: write
      pull-requests: write
    outputs:
      version: ${{ steps.version.outputs.version }}
      finished_at: ${{ steps.finished.outputs.finished_at }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 22
      - id: version
        run: |
          VERSION=$(node -p "require('./package.json').version")
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Create release branch
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git checkout -b release/v${{ steps.version.outputs.version }}
          git push origin release/v${{ steps.version.outputs.version }}

      - name: Create tag
        run: |
          git tag v${{ steps.version.outputs.version }}
          git push origin v${{ steps.version.outputs.version }}
      - name: Update status for Release
        if: always()
        env:
          STATUS_COMMENT_ID: ${{ needs.test.outputs.comment_id }}
        uses: actions/github-script@v7
        with:
          script: |
            const comment_id = parseInt(process.env.STATUS_COMMENT_ID, 10);
            if (!comment_id) { core.setFailed('STATUS_COMMENT_ID is missing'); return; }
            const finished = new Date().toISOString().replace('T',' ').replace('Z',' UTC');
            const icon = '${{ job.status }}' === 'success' ? 'âœ…' :
                        ('${{ job.status }}' === 'failure' ? 'âŒ' : 'âš ï¸');

            const { data: comment } = await github.rest.issues.getComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id
            });
            const updated = comment.body.replace(
              '**Release**: ğŸ”¸ pending',
              `**Release**: ${icon} finished at ${finished}`
            );

            try {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id,
                body: updated
              });
            } catch (e) {
              if (e.status === 403) {
                core.warning('403 updating status comment; creating a new comment as fallback');
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: updated
                });
              } else {
                throw e;
              }
            }
      - id: finished
        run: |
          echo "finished_at=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> "$GITHUB_OUTPUT"

  success:
    name: 6 - Success
    runs-on: ubuntu-latest
    needs: [test, comment, release]
    permissions:
      issues: write
      pull-requests: write
    steps:
      - uses: actions/github-script@v7
        env:
          STATUS_COMMENT_ID: ${{ needs.test.outputs.comment_id }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const prNumber = context.issue.number;
            const version = '${{ needs.release.outputs.version }}';
            const tag = `v${version}`;
            const releaseBranch = `release/v${version}`;
            const baseUrl = `https://${owner}.github.io/${repo}/reports/stable`;
            const coverageUrl = `${baseUrl}/coverage/index.html`;
            const bundleUrl = `${baseUrl}/bundle/sonda_0.html`;
            const branchUrl = `https://github.com/${owner}/${repo}/tree/${releaseBranch}`;
            const tagUrl = `https://github.com/${owner}/${repo}/tree/${tag}`;
            const commitSha = context.payload.pull_request?.merge_commit_sha ?? context.sha;
            const badge = (label, message, color) =>
              `![label](https://img.shields.io/badge/${label}-${message}-${color}?style=for-the-badge)`;
            const badges = [
              `${badge('release', tag, 'darkcyan')}`,
              `${badge('branch', releaseBranch, 'informational')}`,
              `${badge('commit', commitSha.slice(0,7),'rebeccapurple')}`,
              `${badge('status', 'success', 'success')}`
            ].join(' ');

            const MARKER = '<!-- ci-status-marker -->';
            const body = `
            ${MARKER}
            ## ğŸš€ **Release \`${tag}\` is live!** ğŸ‰
            ${badges}

            > This pull request was merged and promoted to **\`${releaseBranch}\`** with tag **\`${tag}\`**.

            **Quick links**
            - ğŸ“¦ **Release branch:** \`${releaseBranch}\`
            - ğŸ·ï¸ **Tag:** \`${tag}\`
            - ğŸ§ª **Coverage report:** [Open](${coverageUrl})
            - ğŸ“Š **Bundle analysis:** [Open](${bundleUrl})
            - ğŸ”— **Merge commit:** \`${commitSha.slice(0,7)}\`

            <details>
            <summary>â„¹ï¸ Checks</summary>

            - **Test & Build**: âœ… passed at ${{ needs.test.outputs.finished_at }}
            - **Report Links Comment**: âœ… passed at ${{ needs.comment.outputs.finished_at }}
            - **Release**: âœ… passed at ${{ needs.comment.outputs.finished_at }}

            </details>

            <details>
            <summary>â„¹ï¸ Details</summary>

            - _Triggered by:_ @${context.actor}
            - _Workflow:_ \`${context.workflow}\`
            - _Run:_ [${context.runNumber}](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}) _If you re-run the workflow, this comment will update automatically._ âœ¨
            `;
            </details>

            const comment_id = parseInt(process.env.STATUS_COMMENT_ID, 10);
            if (!comment_id) { core.setFailed('STATUS_COMMENT_ID is missing'); return; }

            try {
              await github.rest.issues.updateComment({
                owner, repo, comment_id, body
              });
            } catch (e) {
              if (e.status === 403) {
                core.warning('403 updating final status; creating a new summary comment as fallback');
                await github.rest.issues.createComment({
                  owner, repo, issue_number: prNumber, body
                });
              } else {
                throw e;
              }
            }
